{"ast":null,"code":"/**\n * local storage\n */\nexport function getLocalJson(item) {\n  const data = localStorage.getItem(item);\n  if (data) {\n    return JSON.parse(data);\n  } else {\n    return undefined;\n  }\n}\nexport function setLocalJson(item, value) {\n  localStorage.setItem(item, JSON.stringify(value));\n}\n\n/**\n * food auxiar functions\n */\nexport function getRandomItemPosition(screens, size) {\n  const keys = Object.keys(screens);\n  const locations = [];\n  keys.forEach(item => {\n    const screen = screens[item];\n    locations.push([[Math.round(screen.left / size) + 1, Math.round(screen.left / size) + screen.horizontal - 1], [Math.round(screen.top / size) + 1, Math.round(screen.top / size) + screen.vertical - 1]]);\n  });\n  const location = getRandomArrayItem(locations);\n  return getRandomPosition(location);\n}\n\n/**\n * worm auxiar functions\n */\nexport function addWormMove(body, direction) {\n  let newBody = [];\n\n  // verify worm direction and set move\n  body.forEach((element, index) => {\n    if (index === 0) {\n      if (direction === \"right\") {\n        newBody.push([element[0] + 1, element[1]]);\n      }\n      if (direction === \"left\") {\n        newBody.push([element[0] - 1, element[1]]);\n      }\n      if (direction === \"top\") {\n        newBody.push([element[0], element[1] - 1]);\n      }\n      if (direction === \"bottom\") {\n        newBody.push([element[0], element[1] + 1]);\n      }\n    } else {\n      newBody.push([body[index - 1][0], body[index - 1][1]]);\n    }\n  });\n  return newBody;\n}\nexport function verifyMove(body, screens, size) {\n  var _localStorage$getItem, _screens$starter, _screens$starter2, _screens$starter3, _screens$starter4, _screens$starter5, _screens$starter6;\n  // validate self body\n  let status = true;\n  body.some((item, index) => {\n    if (item[0] === body[0][0] && item[1] === body[0][1] && index !== 0) status = false;\n  });\n  if (!status) return false;\n\n  // validate is out of max screen limit\n  const keys = Object.keys(screens);\n  const starter = (_localStorage$getItem = localStorage.getItem(\"starter\")) !== null && _localStorage$getItem !== void 0 ? _localStorage$getItem : \"\";\n  let maxLeft = Math.round(((_screens$starter = screens[starter]) === null || _screens$starter === void 0 ? void 0 : _screens$starter.left) / size);\n  let maxRight = Math.round(((_screens$starter2 = screens[starter]) === null || _screens$starter2 === void 0 ? void 0 : _screens$starter2.left) / size + ((_screens$starter3 = screens[starter]) === null || _screens$starter3 === void 0 ? void 0 : _screens$starter3.horizontal));\n  let maxTop = Math.round(((_screens$starter4 = screens[starter]) === null || _screens$starter4 === void 0 ? void 0 : _screens$starter4.top) / size);\n  let maxBottom = Math.round(((_screens$starter5 = screens[starter]) === null || _screens$starter5 === void 0 ? void 0 : _screens$starter5.top) / size + ((_screens$starter6 = screens[starter]) === null || _screens$starter6 === void 0 ? void 0 : _screens$starter6.vertical));\n\n  // re-set max values\n  keys.forEach((key, index) => {\n    const screen = screens[key];\n    if (Math.round((screen === null || screen === void 0 ? void 0 : screen.left) / size) < maxLeft) maxLeft = Math.round((screen === null || screen === void 0 ? void 0 : screen.left) / size);\n    if (Math.round((screen === null || screen === void 0 ? void 0 : screen.left) / size + (screen === null || screen === void 0 ? void 0 : screen.horizontal)) > maxRight) maxRight = Math.round((screen === null || screen === void 0 ? void 0 : screen.left) / size + (screen === null || screen === void 0 ? void 0 : screen.horizontal));\n    if (Math.round((screen === null || screen === void 0 ? void 0 : screen.top) / size) < maxTop) maxTop = Math.round((screen === null || screen === void 0 ? void 0 : screen.top) / size);\n    if (Math.round((screen === null || screen === void 0 ? void 0 : screen.top) / size + (screen === null || screen === void 0 ? void 0 : screen.vertical)) > maxBottom) maxBottom = Math.round((screen === null || screen === void 0 ? void 0 : screen.top) / size + (screen === null || screen === void 0 ? void 0 : screen.vertical));\n  });\n\n  // verify by max values\n  if (body.length > 0) {\n    if (body[0][0] < maxLeft) return false;\n    if (body[0][0] > maxRight) return false;\n    if (body[0][1] < maxTop) return false;\n    if (body[0][1] > maxBottom) return false;\n  }\n  return true;\n}\nexport function isWormEating(body, foods) {\n  if (body.length > 0 && foods.length > 0) {\n    let value = false;\n    foods.some((item, index) => {\n      if (item[0] === body[0][0] && item[1] === body[0][1]) value = index;\n    });\n    return value;\n  }\n  return false;\n}\nexport function getBlockDirection(worm, index) {\n  const before = worm[index - 1];\n  const current = worm[index];\n  if (before[0] > current[0]) return \"right\";\n  if (before[1] > current[1]) return \"bottom\";\n  if (before[0] < current[0]) return \"left\";\n  return \"top\";\n}\n\n/**\n * utils\n */\nexport function getRandomToken() {\n  const random = Math.floor(Math.random() * 100000);\n  return random.toString();\n}\nfunction getRandomArrayItem(array) {\n  if (array.length === 0) {\n    return undefined;\n  }\n  const randomIndice = Math.floor(Math.random() * array.length);\n  return array[randomIndice];\n}\nfunction getRandomPosition(intervals) {\n  const randomNumbers = [];\n\n  // get random position in interval\n  for (const interval of intervals) {\n    const [min, max] = interval;\n    const randomNumber = Math.random() * (max - min) + min;\n    randomNumbers.push(Math.round(randomNumber - 1));\n  }\n  return randomNumbers;\n}","map":{"version":3,"names":["getLocalJson","item","data","localStorage","getItem","JSON","parse","undefined","setLocalJson","value","setItem","stringify","getRandomItemPosition","screens","size","keys","Object","locations","forEach","screen","push","Math","round","left","horizontal","top","vertical","location","getRandomArrayItem","getRandomPosition","addWormMove","body","direction","newBody","element","index","verifyMove","_localStorage$getItem","_screens$starter","_screens$starter2","_screens$starter3","_screens$starter4","_screens$starter5","_screens$starter6","status","some","starter","maxLeft","maxRight","maxTop","maxBottom","key","length","isWormEating","foods","getBlockDirection","worm","before","current","getRandomToken","random","floor","toString","array","randomIndice","intervals","randomNumbers","interval","min","max","randomNumber"],"sources":["/Users/evelyn/Desktop/EVA/GitHub/cobrinha/src/utils/index.tsx"],"sourcesContent":["import { Direction, WormBody, FoodType, Screens } from \"../types\";\n\n/**\n * local storage\n */\nexport function getLocalJson(item: string) {\n  const data = localStorage.getItem(item);\n\n  if (data) {\n    return JSON.parse(data);\n  } else {\n    return undefined;\n  }\n}\n\nexport function setLocalJson(item: string, value: any) {\n  localStorage.setItem(item, JSON.stringify(value));\n}\n\n/**\n * food auxiar functions\n */\nexport function getRandomItemPosition(screens: Screens, size: number) {\n  const keys = Object.keys(screens);\n\n  const locations: number[][][] = [];\n\n  keys.forEach((item) => {\n    const screen = screens[item];\n    locations.push([\n      [\n        Math.round(screen.left / size) + 1,\n        Math.round(screen.left / size) + screen.horizontal - 1,\n      ],\n      [\n        Math.round(screen.top / size) + 1,\n        Math.round(screen.top / size) + screen.vertical - 1,\n      ],\n    ]);\n  });\n\n  const location = getRandomArrayItem(locations);\n\n  return getRandomPosition(location);\n}\n\n/**\n * worm auxiar functions\n */\nexport function addWormMove(body: WormBody, direction: Direction) {\n  let newBody: WormBody = [];\n\n  // verify worm direction and set move\n  body.forEach((element, index) => {\n    if (index === 0) {\n      if (direction === \"right\") {\n        newBody.push([element[0] + 1, element[1]]);\n      }\n      if (direction === \"left\") {\n        newBody.push([element[0] - 1, element[1]]);\n      }\n      if (direction === \"top\") {\n        newBody.push([element[0], element[1] - 1]);\n      }\n      if (direction === \"bottom\") {\n        newBody.push([element[0], element[1] + 1]);\n      }\n    } else {\n      newBody.push([body[index - 1][0], body[index - 1][1]]);\n    }\n  });\n\n  return newBody;\n}\n\nexport function verifyMove(body: WormBody, screens: Screens, size: number) {\n  // validate self body\n  let status = true;\n  body.some((item, index) => {\n    if (item[0] === body[0][0] && item[1] === body[0][1] && index !== 0)\n      status = false;\n  });\n\n  if (!status) return false;\n\n  // validate is out of max screen limit\n  const keys = Object.keys(screens);\n  const starter = localStorage.getItem(\"starter\") ?? \"\";\n\n  let maxLeft = Math.round(screens[starter]?.left / size);\n  let maxRight = Math.round(\n    screens[starter]?.left / size + screens[starter]?.horizontal\n  );\n  let maxTop = Math.round(screens[starter]?.top / size);\n  let maxBottom = Math.round(\n    screens[starter]?.top / size + screens[starter]?.vertical\n  );\n\n  // re-set max values\n  keys.forEach((key, index) => {\n    const screen = screens[key];\n    if (Math.round(screen?.left / size) < maxLeft)\n      maxLeft = Math.round(screen?.left / size);\n    if (Math.round(screen?.left / size + screen?.horizontal) > maxRight)\n      maxRight = Math.round(screen?.left / size + screen?.horizontal);\n    if (Math.round(screen?.top / size) < maxTop)\n      maxTop = Math.round(screen?.top / size);\n    if (Math.round(screen?.top / size + screen?.vertical) > maxBottom)\n      maxBottom = Math.round(screen?.top / size + screen?.vertical);\n  });\n\n  // verify by max values\n  if (body.length > 0) {\n    if (body[0][0] < maxLeft) return false;\n    if (body[0][0] > maxRight) return false;\n    if (body[0][1] < maxTop) return false;\n    if (body[0][1] > maxBottom) return false;\n  }\n\n  return true;\n}\n\nexport function isWormEating(body: WormBody, foods: FoodType[]) {\n  if (body.length > 0 && foods.length > 0) {\n    let value: number | boolean = false;\n    foods.some((item, index) => {\n      if (item[0] === body[0][0] && item[1] === body[0][1]) value = index;\n    });\n    return value;\n  }\n  return false;\n}\n\nexport function getBlockDirection(worm: WormBody, index: number) {\n  const before = worm[index - 1];\n  const current = worm[index];\n\n  if (before[0] > current[0]) return \"right\";\n  if (before[1] > current[1]) return \"bottom\";\n  if (before[0] < current[0]) return \"left\";\n  return \"top\";\n}\n\n/**\n * utils\n */\nexport function getRandomToken() {\n  const random = Math.floor(Math.random() * 100000);\n  return random.toString();\n}\n\nfunction getRandomArrayItem(array: any[]) {\n  if (array.length === 0) {\n    return undefined;\n  }\n\n  const randomIndice = Math.floor(Math.random() * array.length);\n  return array[randomIndice];\n}\n\nfunction getRandomPosition(intervals: number[][]): number[] {\n  const randomNumbers: number[] = [];\n\n  // get random position in interval\n  for (const interval of intervals) {\n    const [min, max] = interval;\n    const randomNumber = Math.random() * (max - min) + min;\n    randomNumbers.push(Math.round(randomNumber - 1));\n  }\n\n  return randomNumbers;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}